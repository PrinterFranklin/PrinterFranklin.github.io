<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-28T00:10:08.928Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于程序员的工作日志</title>
    <link href="http://example.com/2020/11/29/about-working-log/"/>
    <id>http://example.com/2020/11/29/about-working-log/</id>
    <published>2020-11-29T05:07:36.000Z</published>
    <updated>2020-12-28T00:10:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>从工作的第一个月起，我就开始记工作日志，从刚开始的寥寥几笔，到一年半以后形式逐渐成型，自己在这方面算是略有心得，姑且做个总结。</p><h2 id="写工作日志的必要性"><a href="#写工作日志的必要性" class="headerlink" title="写工作日志的必要性"></a>写工作日志的必要性</h2><ol><li><p><strong>作为便签，防止工作跟丢</strong></p><p>工作之后，每天要处理的事情多而琐碎，手里一件事还没做完，又会来很多新的事，先记录到工作日志，心里有个轻重缓急，按优先级一一处理，完成一件勾掉一件，会很有成就感。</p></li><li><p><strong>便于回溯和总结</strong></p><p>今天做的事，可能一两个月后就记不起来了，有时候需要回溯当时做事的细节，搜索一下就能找到（报加班的时候也方便查到底哪天加了班 :joy:。</p><p>有时候需要站在事后去看自己这周、这个月、这一年完成了些什么，能更清晰地看出自己有哪些不足，哪些值得改进，工作日志是第一手的原材料。</p></li><li><p><strong>记录常用的信息</strong></p><p>工作中有些信息的使用频率很高，比如一些常用的脚本和命令，又比如一些关键文档的归档路径，每次到资料里去查，其实只是想拷贝那一串字符，不如直接放到工作日志里，省时省心。</p></li></ol><h2 id="如何写好工作日志"><a href="#如何写好工作日志" class="headerlink" title="如何写好工作日志"></a>如何写好工作日志</h2><h3 id="使用称手的工具"><a href="#使用称手的工具" class="headerlink" title="使用称手的工具"></a>使用称手的工具</h3><p>理论上所有能<strong>记录结构化信息</strong>的工具都可以作为工作日志的载体，你甚至可以用手写的笔记本，但这里只推荐使用 Typora，理由如下：</p><ul><li>在电脑上记笔记和程序员的习惯是天然吻合的，便于随时调整和修改；</li><li>Markdown 提供了足够强大的标记语法（虽然常用的只有标题分级、有序/无序列表以及代码块），却无需考虑样式，使用它写作能让你最大限度地专注于高效记录信息，不会花费太多额外时间；</li><li>Typora 的“所见即所得”和快速导航功能使它成为写 Markdown 文档不可缺少的辅助；</li><li>Markdown 作为纯文本格式和通用标准，任何平台都能使用，便于归档和使用 Git 管理，甚至可以同步到 GitHub 的个人仓库中。</li></ul><p>第三方商业笔记软件（如印象笔记和幕布）的优点是在移动端也支持得很好，但这类软件出于商业目的，通常不愿意提供将笔记作为通用格式导出的功能，个人也不愿意把重要信息完全交给一家公司托管。</p><blockquote><p>如果有家公司能把基于 Markdown 的多平台云笔记软件做大做成功（意味着它不太可能倒闭，倒闭了我的信息也不会丢），我还是很愿意为之付费的。</p></blockquote><h3 id="设置合理的目录结构"><a href="#设置合理的目录结构" class="headerlink" title="设置合理的目录结构"></a>设置合理的目录结构</h3><p>通常我的工作日志以月为单位，标题就是简单的“20xx年xx月工作日志”。</p><p>每篇日志都包括这几个目录：</p><ol><li><p><strong>整体计划</strong></p><p>首先要记录<u>公司/部门这个月的整体计划</u>（用简单的一两句话概括），这些信息通常能从各类会议中获得，可以随时补充更新。</p><p>其次记录<u>个人在这个月规划的几件重要的事</u>，作为部门的一员，首先要确保自己的计划与部门的相匹配，因为在正确的方向上你的努力才能得到认可。有余力的情况下也可以规划一些额外目标，如个人能力提升或做感兴趣的项目。</p><p>最后还可以加几句提醒自己的话，比如“把事情一次做对”，这个就见仁见智了。</p></li><li><p><strong>工作日志</strong></p><p>这里记录<u>每天的工作信息</u>，列工作是早上要做的第一件事，通常我会每天加一个三级标题，方便快速导航，比如“12月1日（周二）”。</p><blockquote><p>是否要加上星期几，这个因人而异，我喜欢加是因为能一眼看出一个月哪几天加班了 :smile:</p></blockquote><p>标题下面不要直接用一个列表记录所有工作，这样不够清晰，我会按照最重要的两到三块工作划分一下，比如：</p><ul><li>维护工作<ul><li><input checked="" disabled="" type="checkbox"> 修复 xxx 崩溃问题</li><li><input disabled="" type="checkbox"> 上会评审 xxx 问题</li><li><input checked="" disabled="" type="checkbox"> 回复社区 issue</li></ul></li><li>新特性<ul><li><input disabled="" type="checkbox"> 撰写接口文档（已完成 20/45，目标 30/45）</li></ul></li><li>能力提升<ul><li><input disabled="" type="checkbox"> 学习 Kerberos 协议，整理笔记</li><li><input disabled="" type="checkbox"> 学习 CISSP 第 x 章（109-120页）</li></ul></li></ul><p>可以用打勾或者<del>划线</del>的方式标记已经完成的工作。我不会再按“紧急”或“重要”对这些工作排序，这样真的很费时间，特别优先的工作<strong>加粗</strong>表示即可。</p><p>下班的时候可能还没有完成所有的工作，这再正常不过了，把剩下的工作移到明天，用括号标记进度，就可以回家啦。</p><blockquote><p>如果没有这步转移，不仅会导致日志有很多冗余信息，还可能把重要的事遗漏掉。</p></blockquote></li><li><p><strong>工作池</strong></p><p>工作池，或者工作队列，用于存放<u>没有明确完成日期的工作</u>，这些工作的紧急程度相对较低。</p><p>我的工作日志会从上往下写，因为当前写的内容最靠近工作池，做完眼前的事情后，就可以随时从工作池补充新的工作内容。</p><p>工作池的组织方式与工作日志相同，同样按照最重要的几块工作划分，但可以分得更细，有时间就梳理下，没时间也无伤大雅。</p></li><li><p><strong>常用信息</strong></p><p>存放一些经常会用到但又记不住的信息，比如常用的脚本和命令，目的是提高查询/复制粘贴的效率。</p></li></ol><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p><strong>恰当的信息密度</strong></p><p>所谓“恰当”，就是既不要事无巨细，影响工作效率，又不要过于简略，以至于以后读不懂。</p></li><li><p><strong>记得设置 Typora 的<u>自动保存</u></strong></p><p>日志内容丢的时候，别怪我没提醒你。</p></li><li><p><strong>开始新月份的时候，记得把所有没完成的工作拷贝出来</strong></p></li></ul><h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>在华为的一年多时间，我犯过错误，也得到过褒奖，也算在这个庞杂而矛盾的世界中积攒了些许生存经验。</p><p>记录工作日志，只是想帮助自己更轻松地工作，工作占据了我们大半的人生，如果不能从工作中获得很多乐趣，希望我们至少能高效地工作，留出更多的时间陪伴家人、丰富生活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从工作的第一个月起，我就开始记工作日志，从刚开始的寥寥几笔，到一年半以后形式逐渐成型，自己在这方面算是略有心得，姑且做个总结。&lt;/p&gt;
&lt;h2 id=&quot;写工作日志的必要性&quot;&gt;&lt;a href=&quot;#写工作日志的必要性&quot; class=&quot;headerlink&quot; title=&quot;写工作</summary>
      
    
    
    
    <category term="技术人生" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="心得" scheme="http://example.com/tags/%E5%BF%83%E5%BE%97/"/>
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>内核漫游指南</title>
    <link href="http://example.com/2020/11/25/kernel-diving-guide/"/>
    <id>http://example.com/2020/11/25/kernel-diving-guide/</id>
    <published>2020-11-25T00:35:22.000Z</published>
    <updated>2020-12-28T00:10:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>Eric Raymond 在《大教堂与集市》中曾言：</p><blockquote><p>我认为，未来会更多地属于那些告别大教堂、拥抱集市的人们。</p><p>这不是说个人的远见和才华不再重要；而是在我看来，未来的成功者只是从自己的远见和才华开始工作，然后通过有效的社区合作，将其不断地放大。</p><p>开放式的文化会最终胜利，这或许不是因为”开放”在道德上正确，或者”封闭”在道德上错误，而只是因为开放式合作可以在一个问题上投入多几个数量级的技术工时，封闭的世界无法赢得这样的竞争。</p></blockquote><p>本指南献给闯荡银河系的勇者们，愿他们也能领略到内核世界的绝美风光。</p><h2 id="内核源码树"><a href="#内核源码树" class="headerlink" title="内核源码树"></a>内核源码树</h2><table><thead><tr><th>目录</th><th>内容</th><th>备注</th></tr></thead><tbody><tr><td>kernel</td><td>内核核心组件</td><td>除非绝对必要，否则不要向该目录添加内容。</td></tr><tr><td>mm</td><td>架构无关的内存管理代码</td><td></td></tr><tr><td>fs</td><td>所有文件系统实现代码</td><td></td></tr><tr><td>init</td><td>内核初始化相关代码</td><td></td></tr><tr><td>ipc</td><td>进程间通信机制</td><td></td></tr><tr><td>block</td><td>块设备相关代码</td><td></td></tr><tr><td>drivers</td><td>各类驱动程序</td><td>源码中所占空间最大，但只有少量成员会编译到。</td></tr><tr><td>sound</td><td>声卡驱动程序</td><td>尽管有独立的目录，但和其他设备驱动程序类似。</td></tr><tr><td>net</td><td>网络实现代码</td><td>包括核心和各种协议两部分。</td></tr><tr><td>lib</td><td>通用库例程</td><td>包括各种数据结构和数据压缩的例程。</td></tr><tr><td>include</td><td>所有公开导出函数的头文件</td><td></td></tr><tr><td>usr</td><td>cpio 相关实现</td><td></td></tr><tr><td>security</td><td>各类安全模块</td><td>主要包括 LSM 模块和密钥管理代码。</td></tr><tr><td>crypto</td><td>加密层文件</td><td>如各种加密算法的实现。</td></tr><tr><td>virt</td><td>内核虚拟化代码</td><td></td></tr><tr><td>arch</td><td>体系结构相关文件</td><td>每种体系结构都有独立子目录，内部类似于顶层目录。</td></tr><tr><td>samples</td><td>编程范例</td><td>包括内核和用户态编程。</td></tr><tr><td>scripts</td><td>脚本和使用程序</td><td>用于编译内核、检查补丁格式等任务。</td></tr><tr><td>tools</td><td>内核裁剪配置工具</td><td>将源码编译成目标文件，连接合并为可运行的 zImage。</td></tr><tr><td>Documentation</td><td>内核文档</td><td>虽然其中很多过时了。</td></tr><tr><td>LICENSES</td><td>各类相关开源许可证</td><td></td></tr><tr><td>MAINTAINERS</td><td>内核各模块维护者联系方式</td><td></td></tr><tr><td>Kconfig</td><td>编译配置文件</td><td>决定需要编译哪些代码。</td></tr><tr><td>Kbuild</td><td>组件式构建配置文件</td><td></td></tr><tr><td>Makefile</td><td>主 Makefile</td><td>定义 C 编译器、链接器的调用路径。</td></tr></tbody></table><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><h3 id="Kconfig"><a href="#Kconfig" class="headerlink" title="Kconfig"></a>Kconfig</h3><h3 id="Kbuild"><a href="#Kbuild" class="headerlink" title="Kbuild"></a>Kbuild</h3><h2 id="内核开发"><a href="#内核开发" class="headerlink" title="内核开发"></a>内核开发</h2><h3 id="开发工作流"><a href="#开发工作流" class="headerlink" title="开发工作流"></a>开发工作流</h3><h3 id="如何进行补丁移植"><a href="#如何进行补丁移植" class="headerlink" title="如何进行补丁移植"></a>如何进行补丁移植</h3><p>内核开发中一个常见的场景是补丁移植，将高版本内核的修复补丁或特性补丁回合到低版本内核中，往往因为补丁上下文的改动导致无法直接合入，这时候就需要我们手动进行移植。</p><ol><li><p>使用 <code>git am</code> 尝试合入开源补丁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git am xxx.patch</span></span><br></pre></td></tr></table></figure><p>该命令会尝试合入补丁，如果合入顺利，就直接根据补丁头的信息进行提交，如果有冲突，会回退所有的修改并告知哪里有冲突。</p><blockquote><p>你可以加上 <code>-s</code> 选项以在提交信息中附加自己的签名。</p></blockquote></li><li><p>出现冲突时的处理。</p><ul><li><p>首先判断冲突是否是因为补丁内容已经存在于源码中，如果是，就直接跳过补丁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git am --skip</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>git apply</code> 合入未冲突的部分修改，并通过 <code>--reject</code> 选项导出冲突内容到一个 .rej 文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git apply --reject xxx.patch</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>vim -O</code> 同时打开 .rej 文件和源文件，以便手动适配合入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim -O crashfile.rej crashfile</span></span><br></pre></td></tr></table></figure><p>根据补丁上下文，从 .rej 文件复制对应的修改到原文件，删除应该删除的行。</p></li><li><p>清理 .rej 文件并使用 <code>git add</code> 添加修改到文件，最后完成提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -f crashfile.rej</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git am --resolved</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>合入补丁后，根据需要补充补丁头信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure></li><li><p>生成单个新补丁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git format-patch --subject-prefix=<span class="string">&quot;PATCH version_prefix&quot;</span> -1</span></span><br></pre></td></tr></table></figure><p>一次生成完整的补丁集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git format-patch --subject-prefix=<span class="string">&quot;PATCH version_prefix&quot;</span> --cover-letter [commit-ID]</span></span><br></pre></td></tr></table></figure></li><li><p>检查补丁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scripts/checkpatch.pl xxx.patch</span></span><br></pre></td></tr></table></figure></li><li><p>发送补丁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git send-email *.patch -to <span class="string">&quot;maintainer email&quot;</span> --cc=<span class="string">&quot;kernel.openeuler@huawei.com&quot;</span> --from=<span class="string">&quot;your email&quot;</span> --suppress-cc=all</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><h2 id="内核调测"><a href="#内核调测" class="headerlink" title="内核调测"></a>内核调测</h2><h3 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h3><h4 id="procfs"><a href="#procfs" class="headerlink" title="procfs"></a>procfs</h4><h4 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h4><h3 id="常规调试"><a href="#常规调试" class="headerlink" title="常规调试"></a>常规调试</h3><h4 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h4><h4 id="kprobe"><a href="#kprobe" class="headerlink" title="kprobe"></a>kprobe</h4><h4 id="SystemTap"><a href="#SystemTap" class="headerlink" title="SystemTap"></a>SystemTap</h4><h4 id="KGDB"><a href="#KGDB" class="headerlink" title="KGDB"></a>KGDB</h4><h4 id="KGTP"><a href="#KGTP" class="headerlink" title="KGTP"></a>KGTP</h4><h3 id="崩溃调试"><a href="#崩溃调试" class="headerlink" title="崩溃调试"></a>崩溃调试</h3><h4 id="kdump"><a href="#kdump" class="headerlink" title="kdump"></a>kdump</h4><p>kdump 是一种内核崩溃转储机制，能够在系统崩溃时自动转储内存，以用于后续分析。</p><p>kdump 工作过程如下：</p><ol><li><p>系统内核启动的时候，为 capture 内核预留一块内存空间，该空间无法被当前内核访问；</p><blockquote><p>这块空间的大小及其在内存中的偏移可通过启动参数中的 <code>crashkernel=size[@offset]</code> 指定。</p></blockquote></li><li><p>内核启动完成后，kdump 服务执行 <code>kexec -p</code> 把 capture 内核载入预留的内存；</p></li><li><p>如果当前内核发生崩溃，就自动把控制权交给 capture 内核（capture 内核仅使用预留内存，因此其余内存数据不会被改动），由该内核把崩溃内核内存中的数据写入到 dump 文件；</p></li><li><p>写完 dump 文件中，capture 内核自动重启。</p></li></ol><p>这里不过多介绍 kdump 的设置，读者可以在各发行版的文档中找到（例如<a class="link"   href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/kernel_administration_guide/kernel_crash_dump_guide" >红帽<i class="fas fa-external-link-alt"></i></a>），直接介绍如何通过 vmcore 文件获取系统崩溃信息。</p><h4 id="SysRq-魔术键"><a href="#SysRq-魔术键" class="headerlink" title="SysRq 魔术键"></a>SysRq 魔术键</h4><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><h4 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h4><p>性能分析的“瑞士军刀”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h2 id="变更记录"><a href="#变更记录" class="headerlink" title="变更记录"></a>变更记录</h2><ul><li>2020.11.25：完成目录框架。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Eric Raymond 在《大教堂与集市》中曾言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为，未来会更多地属于那些告别大教堂、拥抱集市的人们。&lt;/p&gt;
&lt;p&gt;这不是说个人的远见和才华不再重要；而是在我看来，未来的成功者只是从自己的远见和才华开始工作，然后通过有效的社</summary>
      
    
    
    
    <category term="知识地图" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%9C%B0%E5%9B%BE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入 Linux 审计机制</title>
    <link href="http://example.com/2020/11/17/linux-audit-guide/"/>
    <id>http://example.com/2020/11/17/linux-audit-guide/</id>
    <published>2020-11-17T14:41:37.000Z</published>
    <updated>2020-12-28T00:10:08.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="理解审计"><a href="#理解审计" class="headerlink" title="理解审计"></a>理解审计</h3><p>审计（audit）这个概念最初来自于会计领域，意为对一个组织或个体的账户和财务状态进行正式评估：</p><blockquote><p>An <strong>audit</strong> is an “independent examination of financial information of any entity, whether profit oriented or not, irrespective of its size or legal form when such an examination is conducted with a  view to express an opinion thereon”.</p></blockquote><p>投资者无法判断企业的财务报表有没有水分，因此雇佣专业的第三方（会计事务所）作为裁判来鉴别财务报表的真实性，以防作弊。</p><p>审计有两个关键词：</p><ul><li>独立的第三方</li><li>正式</li></ul><p>在信息安全领域，被审计的对象就是信息系统，审计的维度不再局限于真实性，还包括机密性、完整性、可用性等多个维度，</p><p>具体到 Linux 系统中，审计过程的第三方就是内核，“正式”意味着在内核中根据设定的规则生成审计消息。</p><p>日志和审计常常被一起提及，因为它们都记录了系统的行为，区别在于：</p><ul><li>日志的主体是应用程序，每个进程都可以发送消息给日志服务，相当于“主动向组织交代情况”，严格说来日志是不可靠的，因为进程可以多发、少发、不发甚至错发日志消息。</li><li>审计的主体是内核，无论进程是否发送消息，内核都能记录进程的足迹（例如访问了什么文件，走了什么系统调用），相当于“Big brother is watching you”（误），至于在哪些位置放摄像头，则是由审计规则决定的。</li></ul><p>日志属于调测领域，审计属于安全领域，这是两者本质的区别。</p><h3 id="内核中的审计"><a href="#内核中的审计" class="headerlink" title="内核中的审计"></a>内核中的审计</h3><p>整个审计子系统的各部分构成如下：</p><p><img src="https://documentation.suse.com/sles/11-SP4/html/SLES-all/images/audit_components.png" alt="Introducing the Components of Linux Audit"></p><p>内核中的 audit 子系统是审计系统的核心，</p><p>除此以外，审计子系统也提供了一系列用户态组件方便用户使用：</p><ul><li>auditd 服务进程是 Linux 审计子系统的用户态组件，负责将审计结果写到日志。<ul><li><code>/etc/audit/auditd.conf</code> 文件用于配置 auditd 服务进程的行为。</li></ul></li><li>audispd 负责给其他应用发送事件通知。</li><li>audit.log 文件记录了度量日志<ul><li>aureport 用于生成个性化的报告。</li><li>ausearch 用于检索信息。</li></ul></li><li>auditctl 命令负责配置审计规则<ul><li><code>/etc/audit/audit.rules</code></li><li><code>/etc/audit/rules.d/*</code></li></ul></li><li>autrace 通过与 strace 类似的方式对系统调用进行跟踪</li></ul><h2 id="用户视角：使用审计机制"><a href="#用户视角：使用审计机制" class="headerlink" title="用户视角：使用审计机制"></a>用户视角：使用审计机制</h2><h3 id="开启审计服务"><a href="#开启审计服务" class="headerlink" title="开启审计服务"></a>开启审计服务</h3><p>首先查看内核审计子系统的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> auditctl -s</span></span><br><span class="line">enabled 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>enabled 参数表示系统审计开关，可通过 <code>-e</code> 选项设置，取值包括 <code>0|1|2</code> 三种：</p><ul><li><code>0</code> 表示禁用审计；</li><li><code>1</code> 表示启用审计（默认）；</li><li><code>2</code> 表示启用审计并锁定配置，锁定后所有配置无法更改，直到重新启动。</li></ul><blockquote><p>注：如果出现 <code>audit support not in kernel</code> 字样，表示审计模块未加载进内核，可能是内核启动参数中加了 <code>aduit=0</code> 的限制，需要删除该字段或将其修改为 <code>audit=1</code>。</p></blockquote><p>内核审计系统启用的情况下，能够正常获取审计信息，但还需要启动用户态的 auditd 服务收集和记录日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service auditd status    <span class="comment"># 查看auditd服务状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service auditd start     <span class="comment"># 启用auditd服务</span></span></span><br></pre></td></tr></table></figure><p>可通过 <code>/etc/audit/auditd.conf</code> 文件配置 auditd 服务，常见配置包括：</p><table><thead><tr><th>配置项</th><th>含义</th><th>推荐设置</th></tr></thead><tbody><tr><td>write_logs</td><td>是否写日志</td><td>yes</td></tr><tr><td>log_file</td><td>日志路径</td><td>/var/log/audit/audit.log</td></tr><tr><td>max_log_file</td><td>日志文件大小上限（以 MB 为单位）</td><td>8</td></tr><tr><td>max_log_file_action</td><td>日志文件到达上限后的动作</td><td>keep_logs</td></tr><tr><td>space_left</td><td>磁盘剩余空间下限</td><td>75</td></tr><tr><td>space_left_action</td><td>磁盘剩余空间不足下限后的动作</td><td>email 或 exec（执行脚本）</td></tr><tr><td>flush</td><td>日志文件更新后磁盘的同步策略</td><td>sync 或 data</td></tr></tbody></table><blockquote><p>更多参数和解释可以在 auditd.conf(5) 手册页中找到。</p></blockquote><p>更新此配置文件后需要重启 auditd 服务才能生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service auditd restart</span></span><br></pre></td></tr></table></figure><h3 id="配置审计规则"><a href="#配置审计规则" class="headerlink" title="配置审计规则"></a>配置审计规则</h3><p>auditctl 命令可被用于配置审计规则，例如审计对 <code>/etc/ssh/sshd_config</code> 文件的所有访问</p><ul><li><code>-w</code> 选项指定要审计的文件路径。</li><li><code>-p</code> 选项描述系统调用对文件的访问动作：<ul><li>rwx 分别表示读文件、写文件、执行文件；</li><li>a 表示文件属性修改。</li></ul></li><li><code>-k</code> 选项指定过滤关键词，生成的审计日志消息会包含这个关键词，后续可用于日志过滤。</li><li><code>-a</code> 选项</li><li><code>-S</code> 选项</li><li><code>-F</code> 选项</li></ul><blockquote><p>更多选项和解释可以在 audit.rules(7) 手册页中找到。</p></blockquote><p>如果需要每次启动都生效，可以通过配置 <code>/etc/audit/audit.rules</code> 文件或在 <code>/etc/audit/rules.d</code> 目录新增配置文件实现，配置文件的内容就是加在 auditctl 命令后的选项和参数。</p><p>常见配置如下：</p><ul><li><p>不配置审计规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D</span><br><span class="line">-e 0</span><br></pre></td></tr></table></figure></li><li><p>审计登录事件，添加如下规则行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-w /var/log/faillog -p wa -k logins</span><br><span class="line">-w /var/log/lastlog -p wa -k logins</span><br></pre></td></tr></table></figure></li><li><p>审计内核模块加载、卸载事件，添加如下规则行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-w /sbin/insmod -p x -k modules</span><br><span class="line">-w /sbin/rmmod -p x -k modules</span><br><span class="line">-w /sbin/modprobe -p x -k modules</span><br><span class="line">-a always,exit -F arch=b64 -S init_module -S delete_module -k modules</span><br></pre></td></tr></table></figure></li><li><p>在所有配置项后增加 <code>-e 2</code> 可</p></li></ul><p>配置完成后，可以使用 <code>-l</code> 选项查看系统当前审计规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> auditctl -l              <span class="comment"># 查看所有生效的审计规则</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> auditctl -l -k logins    <span class="comment"># 查看所有包含logins关键词的审计规则</span></span></span><br></pre></td></tr></table></figure><p>使用 <code>-D</code> 选项删除审计规则（通常会配置 <code>-k</code> 选项使用，不加的话就是删除所有规则）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> auditctl -D              <span class="comment"># 删除所有审计规则</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> auditctl -D -k logins    <span class="comment"># 删除所有包含logins关键词的审计规则</span></span></span><br></pre></td></tr></table></figure><p>一方面，配置的审计规则越多，监控的事件就越多，系统会更加安全，另一方面，大量审计规则也会带来性能影响，所以用户需要根据实际情况设置规则。</p><h3 id="阅读审计日志"><a href="#阅读审计日志" class="headerlink" title="阅读审计日志"></a>阅读审计日志</h3><p>审计日志记录了审计活动的结果，通常位于 <code>/var/log/audit/audit.log</code> 路径下，通过阅读审计日志，我们能得到许多关于系统状态的信息。</p><h4 id="理解日志"><a href="#理解日志" class="headerlink" title="理解日志"></a>理解日志</h4><p>以一个典型的审计事件为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type=SYSCALL msg=audit(1434371271.277:135496): arch=c000003e syscall=2 success=yes exit=3 a0=7fff0054e929 a1=0 a2=1fffffffffff0000 a3=7fff0054c390 items=1 ppid=6265 pid=6266 auid=1000 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=113 comm=&quot;cat&quot; exe=&quot;/usr/bin/cat&quot; key=&quot;sshconfigchange&quot;</span><br><span class="line"></span><br><span class="line">type=CWD msg=audit(1434371271.277:135496):  cwd=&quot;/home/sammy&quot;</span><br><span class="line"></span><br><span class="line">type=PATH msg=audit(1434371271.277:135496): item=0 name=&quot;/etc/ssh/sshd_config&quot; inode=392210 dev=fd:01 mode=0100600 ouid=0 ogid=0 rdev=00:00 objtype=NORMAL</span><br></pre></td></tr></table></figure><ul><li><p><code>type</code>：表示审计事件的类型，<code>type=SYSCALL</code> 表示日志由系统调用所触发；</p></li><li><p><code>msg</code>：表示时间戳和事件 ID（同一审计事件可能有多条记录，但都有相同的事件 ID）；</p></li><li><p><code>arch</code>：表示 CPU 体系结构（<code>c000003e</code> 对应 x86，<code>c00000b7</code> 对应 arm）；</p></li><li><p><code>syscall</code>：表示触发事件的系统调用号，可通过 ausyscall 命令查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ausyscall 189       <span class="comment"># 查询189号系统调用</span></span></span><br><span class="line">lsetxattr</span><br><span class="line"><span class="meta">$</span><span class="bash"> ausyscall --dump    <span class="comment"># 列出所有支持审计的系统调用</span></span></span><br><span class="line">0       read</span><br><span class="line">1       write</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><code>success</code>：表示系统调用返回成功与否；</p></li><li><p><code>exit</code>：表示系统调用的返回值；</p></li><li><p><code>a0-a3</code>：传递给系统调用的前四个参数；</p></li><li><p><code>ppid</code>：表示父进程 ID；</p></li><li><p><code>pid</code>：表示触发系统调用的进程 ID；</p></li><li><p><code>auid</code></p></li><li><p><code>uid</code></p></li><li><p><code>comm</code>：表示触发审计的命令；</p></li><li><p><code>exe</code>：表示触发审计的命令的文件路径；</p></li><li><p><code>key</code>：表示审计规则中定义的标签；</p></li><li></li></ul><h4 id="检索有效信息"><a href="#检索有效信息" class="headerlink" title="检索有效信息"></a>检索有效信息</h4><p>audit 日志文件的信息很多，日志很不方便，</p><h4 id="生成审计报告"><a href="#生成审计报告" class="headerlink" title="生成审计报告"></a>生成审计报告</h4><p>生成有关可执行文件的审计事件的报告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aureport -x</span></span><br></pre></td></tr></table></figure><p>也可以结合 ausearch 命令生成报告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ausearch --start today --loginuid 500 --raw | aureport -f --summary</span></span><br></pre></td></tr></table></figure><blockquote><p>更多选项及使用方法，请参考 aureport(8) 手册页。</p></blockquote><h2 id="开发者视角：调用审计接口"><a href="#开发者视角：调用审计接口" class="headerlink" title="开发者视角：调用审计接口"></a>开发者视角：调用审计接口</h2><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>首先调用 <code>audit_log_start</code> 函数申请一个缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct audit_buffer *<span class="title">audit_log_start</span><span class="params">(struct audit_context *ctx, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>【入参1】audit_context：审计上下文</li><li>【入参2】gfp_mask：缓冲区类型，通常是 GFP_KERNEL</li><li>【入参3】type：审计日志类型</li><li>【返回值】audit_buffer：缓冲区指针</li></ul><p>然后调用 <code>audit_log_format</code> 往缓冲区中写日志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audit_log_format</span><span class="params">(struct audit_buffer *ab, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>【入参1】audit_buffer：审计缓冲区</li><li>【入参2】fmt：格式化字符串</li><li>【入参3】可变参数</li><li>【返回值】空</li></ul><p>最后调用 <code>audit_log_end</code> 结束写日志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audit_log_end</span><span class="params">(struct audit_buffer *ab)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>【入参1】audit_buffer：审计缓冲区</li><li>【返回值】空</li></ul><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_audit_msg</span><span class="params">(<span class="keyword">int</span> audit_msgno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">audit_buffer</span> *<span class="title">ab</span>;</span></span><br><span class="line">    </span><br><span class="line">ab = audit_log_start(audit_context(), GFP_KERNEL, audit_msgno);</span><br><span class="line">    </span><br><span class="line">    audit_log_format();</span><br><span class="line">    </span><br><span class="line">    audit_log_end(ab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核源码剖析"><a href="#内核源码剖析" class="headerlink" title="内核源码剖析"></a>内核源码剖析</h2><p>审计机制属于内核最核心的部分，因此代码都在 <code>kernel</code> 目录下，首先对文件有个大致的了解：</p><ul><li><code>audit.h</code>：头文件，定义审计机制使用的通用结构体和函数；</li><li><code>audit.c</code>：提供核心审计机制；</li><li><code>auditsc.c</code>：实际了对系统调用的审计；</li><li><code>auditfilter.c</code>：包含了过滤审计事件的机制；</li><li><code>audit_fsnotify.c</code></li><li><code>audit_tree.c</code></li><li><code>audit_watch.c</code></li></ul><p>其中，<code>audit.c</code>、<code>auditsc.c</code> 和 <code>auditfilter.c</code> 是最核心的</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="audit-context"><a href="#audit-context" class="headerlink" title="audit_context"></a>audit_context</h4><h3 id="审计过程"><a href="#审计过程" class="headerlink" title="审计过程"></a>审计过程</h3><h4 id="开始审计"><a href="#开始审计" class="headerlink" title="开始审计"></a>开始审计</h4><p>本质上 <code>audit_log_start</code> 的工作是建立一个 audit_buffer 实例并将其返回给调用者，但在此之前需要考虑积压队列的长度限制和发送数据的速率限制。</p><p>如果积压队列长度和数据速率限制的检查能够通过，则使用 <code>audit_buffer_alloc</code> 分配一个 <code>audit_buffer</code> 实例。</p><h4 id="写入记录消息"><a href="#写入记录消息" class="headerlink" title="写入记录消息"></a>写入记录消息</h4><h4 id="结束审计记录"><a href="#结束审计记录" class="headerlink" title="结束审计记录"></a>结束审计记录</h4><p>在所有必要的记录消息都已经写入到审计缓冲区之后，需要调用 <code>audit_log_end</code> 确保将审计记录发送给用户空间守护进程。</p><h3 id="系统调用审计"><a href="#系统调用审计" class="headerlink" title="系统调用审计"></a>系统调用审计</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>man 手册页</li><li>开发者官网：<a class="link"   href="https://linux-audit.com/" >https://linux-audit.com<i class="fas fa-external-link-alt"></i></a></li><li>CentOS 7 审计系统使用指南：<a class="link"   href="https://www.digitalocean.com/community/tutorials/how-to-use-the-linux-auditing-system-on-centos-7" >https://www.digitalocean.com/community/tutorials/how-to-use-the-linux-auditing-system-on-centos-7<i class="fas fa-external-link-alt"></i></a></li><li>SUSE 提供的资料：<a class="link"   href="https://documentation.suse.com/sles/11-SP4/html/SLES-all/cha-audit-comp.html" >https://documentation.suse.com/sles/11-SP4/html/SLES-all/cha-audit-comp.html<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="变更记录"><a href="#变更记录" class="headerlink" title="变更记录"></a>变更记录</h2><ul><li>2020.11.20：添加“函数接口”。</li><li>2020.11.18：完成“使用审计机制-开启审计服务”。</li><li>2020.11.17：完成目录框架。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;理解审计&quot;&gt;&lt;a href=&quot;#理解审计&quot; class=&quot;headerlink&quot; title=&quot;理解审计&quot;&gt;&lt;/a&gt;理解审计&lt;/h</summary>
      
    
    
    
    <category term="知识地图" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%9C%B0%E5%9B%BE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于 Linux 你需要了解的 x 个基本命令</title>
    <link href="http://example.com/2020/11/17/linux-basic-commands/"/>
    <id>http://example.com/2020/11/17/linux-basic-commands/</id>
    <published>2020-11-16T16:15:48.000Z</published>
    <updated>2020-12-28T00:10:08.932Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Linux 绕不开命令行，而记忆命令就像背单词，是绕不过的基本功。</p><p>本文的目的是精挑细选，保留常见命令中的一个最小命令集，只提供其中使用频率最高的用法，原则是<strong>如无必要，勿增实体</strong>，在足够应对日常工作的前提下，尽可能地减小记忆负担。</p><blockquote><p>例如，删除一个目录，可以使用 <code>rm -rf</code>，也可以使用 <code>rmdir</code>，后者在这种情况下就是多余的。</p></blockquote><p>你可以通过两种方法阅读本篇文章：</p><ul><li>作为教材：按照顺序从头往下逐个学习，或者按照场景分类进行学习。</li><li>作为手册：使用 <code>Ctrl+F</code> 搜索需要查询的命令。</li></ul><p>由于工作原因，笔者暂时无法一次性完成整篇文章，但会坚持至少一天更新一个命令，请大家监督 :-)</p><p>如果你对于命令的选取有疑问或有更好的见解，请在文章末尾留言。</p><h2 id="查询与帮助命令"><a href="#查询与帮助命令" class="headerlink" title="查询与帮助命令"></a>查询与帮助命令</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><code>man</code> 是 manual 的简称，当用户需要查看某个命令的参数时，只需要执行 <code>man</code> 即可获取相关资料（当然你也可以通过 <code>man man</code> 来查看 <code>man</code> 命令的用法）。</p><p>man 手册可分为以下 9 种类型：</p><ol><li><strong>标准用户命令（Executable programs or shell commands）</strong></li><li><strong>系统调用（System Calls）</strong></li><li><strong>库调用（Library Calls）</strong></li><li>特殊文件访问入口（Special files）</li><li><strong>文件格式约定（File formats and conventions）</strong></li><li>游戏（Games）</li><li>杂项（Miscellaneous）</li><li><strong>系统管理命令（System administration commands）</strong></li><li>内核相关文件（Kernel routines）</li></ol><p>举例说明，<code>read</code> 既是系统调用，又是 bash 命令，查看 man 手册的时候需要作区分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> man 1 <span class="built_in">read</span>    <span class="comment"># 查看作为命令的read</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man 2 <span class="built_in">read</span>    <span class="comment"># 查看作为系统调用的read</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man 3 <span class="built_in">read</span>    <span class="comment"># 查看作为库调用的read</span></span></span><br></pre></td></tr></table></figure><p>如果不确定应该打开哪一类 man 手册，可以先通过 <code>whatis</code> 命令查询关键字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> whatis <span class="built_in">read</span></span></span><br></pre></td></tr></table></figure><p>man 手册通常包括以下章节：</p><ul><li><strong>NAME</strong>：命令名称和一句话简要描述</li><li>SYNOPSIS：列出命令的所有可用选项</li><li><strong>EXAMPLES</strong>：常见用法举例</li><li><strong>DESCRIPTION</strong>：概念介绍</li><li><strong>OPTIONS</strong>：对命令参数的详细说明</li><li>EXIT STATUS：返回状态码说明</li><li>ENVIRONMENT：涉及的环境变量</li><li><strong>FILES</strong>：相关文件（通常是配置文件）</li><li>AUTHOR：作者署名</li><li>SEE ALSO：更多参考资料</li></ul><p>下面是 man 手册的使用方法：</p><ul><li>翻页<ul><li>向后翻一行：Enter（回车）</li><li>向前翻一行：k</li><li>向后翻一页：space（空格）</li><li>向前翻一页：b</li></ul></li><li>查找<ul><li>向后搜索关键词：/KEYWORD</li><li>向前搜索关键词：?KEYWORD</li><li>跳转到下个关键词：n</li><li>跳转到上个关键词：N</li></ul></li><li>退出：q</li></ul><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><h2 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h3><h3 id="yum-dnf"><a href="#yum-dnf" class="headerlink" title="yum / dnf"></a>yum / dnf</h3><h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><p>dpkg 是 Debian 类 Linux 发行版的包管理程序，常见用法包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dpkg -i [.deb package name]    <span class="comment"># 安装软件包</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dpkg -c [.deb package name]    <span class="comment"># 列出一个未安装的软件包的所有文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dpkg -l [pacakge name]         <span class="comment"># 查询一个软件包是否安装</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dpkg -L [package name]         <span class="comment"># 列出一个已安装的软件包的所有文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dpkg -s [package name]         <span class="comment"># 查询一个软件包的详细信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dpkg -r [package name]         <span class="comment"># 删除一个软件包，并保留配置目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dpkg -P [package name]         <span class="comment"># 删除一个软件包，但不保留配置目录</span></span></span><br></pre></td></tr></table></figure><h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><h3 id="unalias"><a href="#unalias" class="headerlink" title="unalias"></a>unalias</h3><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><h2 id="关机相关命令"><a href="#关机相关命令" class="headerlink" title="关机相关命令"></a>关机相关命令</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p><code>ln</code> 命令的功能是为文件在另一个位置建立链接，当我们需要在不同目录用到相同的文件时，只要在其中一个目录下存储该文件，然后在其他目录建立对它的链接，从而减少了重复的空间占用。</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><h3 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h3><h3 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h3><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><h3 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a>md5sum</h3><h2 id="查看文件和内容处理命令"><a href="#查看文件和内容处理命令" class="headerlink" title="查看文件和内容处理命令"></a>查看文件和内容处理命令</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><h3 id="dos2unix"><a href="#dos2unix" class="headerlink" title="dos2unix"></a>dos2unix</h3><h3 id="vimdiff"><a href="#vimdiff" class="headerlink" title="vimdiff"></a>vimdiff</h3><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><h3 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi / vim"></a>vi / vim</h3><h2 id="压缩归档命令"><a href="#压缩归档命令" class="headerlink" title="压缩归档命令"></a>压缩归档命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><h2 id="系统状态显示命令"><a href="#系统状态显示命令" class="headerlink" title="系统状态显示命令"></a>系统状态显示命令</h2><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><h3 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h3><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><h3 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h3><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>最简单的身份切换命令，最常见的用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> su - [username]    <span class="comment"># 切换到username指定的用户，需要输入新用户的密码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> su -               <span class="comment"># 默认切换到root用户，需要输入root用户的密码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> su [username]      <span class="comment"># 切换到username指定的用户，区别是环境变量和原来保持一致，并未更新</span></span></span><br></pre></td></tr></table></figure><p>要完整地切换到新用户的环境，必须使用 <code>su - username</code> 或 <code>su -l username</code>，才会连同 PATH、USER、MAIL 等变量都转成新用户的环境。</p><p>使用 root 切换成其他用户时，不需要输入新用户的密码。</p><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><h3 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h3><h3 id="users"><a href="#users" class="headerlink" title="users"></a>users</h3><h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><h2 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h2><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><h3 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h3><h3 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a>ifdown</h3><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><h2 id="磁盘与文件系统命令"><a href="#磁盘与文件系统命令" class="headerlink" title="磁盘与文件系统命令"></a>磁盘与文件系统命令</h2><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><h2 id="性能监控命令"><a href="#性能监控命令" class="headerlink" title="性能监控命令"></a>性能监控命令</h2><h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h3><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 Linux 绕不开命令行，而记忆命令就像背单词，是绕不过的基本功。&lt;/p&gt;
&lt;p&gt;本文的目的是精挑细选，保留常见命令中的一个最小命令集，只提供其中使用频率最高的用法，原则是&lt;strong&gt;如无必要，勿增实体&lt;/strong&gt;，在足够应对日常工作的前提下，尽可能地减小记</summary>
      
    
    
    
    <category term="知识地图" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%9C%B0%E5%9B%BE/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统工程师生存指南（2020）</title>
    <link href="http://example.com/2020/11/11/kernel-developer-surviving-guide/"/>
    <id>http://example.com/2020/11/11/kernel-developer-surviving-guide/</id>
    <published>2020-11-11T00:38:42.000Z</published>
    <updated>2020-12-28T00:10:08.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="角色定位"><a href="#角色定位" class="headerlink" title="角色定位"></a>角色定位</h2><p>从事任何行业都应当首先找准自己的角色定位，即世界需要什么，以及自身能够贡献何种价值。</p><p>操作系统开发的特点：</p><ol><li>OS 开发门槛较高，需要扎实的计算机基础知识，培养一名能够投入工作的系统开发者所需的时间远远长于应用开发者。</li><li>由于 Linux 的稳定性和广泛使用，系统开发者的职业寿命也相对较长，掌握的技能不容易被时间淘汰。</li><li>相比于前后端开发，初创公司对系统开发者几乎没有需求（个别初创硬件公司除外），系统开发者很难得到上市“暴富”的机会，但大型公司通常有构建自己底层框架的需要，经验丰富的系统开发者依然抢手，不难得到一份体面的薪资。</li><li>系统开发有自身的节奏，偏向于研究和“憋大招”，短期不会有太强的交付压力，适合 work-life balance。</li><li>系统开发工作与开源社区联系紧密，这意味着自己的工作不止在公司内产生影响，长期看有利于打造个人品牌（比如成为社区 Maintainer），在雇主面前掌握议价权。</li></ol><h2 id="能力地图"><a href="#能力地图" class="headerlink" title="能力地图"></a>能力地图</h2><h3 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h3><ul><li>计算机系统原理 ☆☆</li><li>数据结构和算法 ☆☆</li><li>操作系统 ☆☆☆</li><li>计算机网络 ☆</li><li>编译原理 ☆</li></ul><h3 id="开发与测试"><a href="#开发与测试" class="headerlink" title="开发与测试"></a>开发与测试</h3><ul><li>C 语言基础 ☆☆☆</li><li>Linux C 编程 ☆☆☆</li><li>构建大型 C 程序 ☆☆☆</li><li>C 程序调试 ☆☆</li><li>C 单元测试 ☆</li><li>开发工具链 ☆☆</li><li>软件架构和设计模式 ☆☆</li><li>现代编程语言（Python/Go/Rust/…）☆</li></ul><h3 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h3><ul><li>基础知识 ☆☆☆</li><li>基本技能（如写脚本和打包） ☆☆☆</li><li>内核原理 ☆☆☆</li><li>虚拟化、容器与云计算 ☆☆</li></ul><h3 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h3><ul><li>开源文化 ☆</li><li>软件工程 ☆</li><li>非技术：写作 ☆</li></ul><h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><h3 id="公共信息源"><a href="#公共信息源" class="headerlink" title="公共信息源"></a>公共信息源</h3><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><p>通过书籍学习的特点是经典，不容易过时。</p><ul><li><strong>计算机原理</strong><ul><li><strong>计算机系统原理</strong><ul><li><em>编码：隐匿在计算机软硬件背后的语言</em></li><li><em>计算机组成与设计：硬件/软件接口</em></li><li><em>深入理解计算机系统</em></li><li><em>计算机体系结构：量化研究方法</em></li></ul></li><li><strong>数据结构和算法</strong><ul><li><em>算法图解：像小说一样有趣的算法入门书</em></li><li><em>数据结构和算法：C 语言描述</em></li><li><em>算法导论</em></li></ul></li><li><strong>操作系统</strong><ul><li><em>现代操作系统</em></li><li><em>操作系统：精髓与设计原理</em></li><li><em>操作系统导论</em></li></ul></li><li><strong>计算机网络</strong><ul><li><em>计算机网络：自顶向下方法</em></li><li><em>TCP / IP 详解（卷一：协议）</em></li></ul></li><li><strong>编译原理</strong><ul><li><em>编译原理（龙书）</em></li></ul></li></ul></li><li><strong>开发与测试</strong><ul><li><strong>C 语言基础</strong><ul><li><em>C 程序设计语言</em></li><li><em>C Primer</em></li><li><em>C 和指针</em></li><li><em>C 陷阱与缺陷</em></li><li><em>C 专家编程</em></li></ul></li><li><strong>Linux C 编程</strong><ul><li><em>UNIX 环境高级编程</em></li><li><em>Linux/UNIX 系统编程手册</em></li><li><em>Linux 程序设计</em></li></ul></li><li><strong>构建大型 C 程序</strong><ul><li><em>程序员的基本修养：链接、装载与库</em></li></ul></li><li><strong>C 程序调试</strong></li><li><strong>C 单元测试</strong></li><li><strong>开发工具链</strong><ul><li><em>Pro Git</em></li></ul></li><li><strong>软件架构和设计模式</strong><ul><li><em>代码整洁之道</em></li><li><em>架构整洁之道</em></li></ul></li><li><strong>现代编程语言（Python/Go/Rust/…）</strong><ul><li><em>Python 学习手册</em></li></ul></li></ul></li><li><strong>Linux 基础</strong><ul><li><strong>基础知识</strong><ul><li><em>鸟哥的 Linux 私房菜</em></li></ul></li><li><strong>基本技能</strong><ul><li><em>Linux 命令行与 Shell 脚本编程大全</em></li><li><em>RPM Spec Guide</em></li></ul></li><li><strong>内核原理</strong><ul><li><em>Linux 系统设计与实现</em></li><li><em>Linux 设备驱动程序</em></li><li><em>深入理解 Linux 内核</em></li><li><em>深入 Linux 内核架构</em></li></ul></li><li><strong>虚拟化技术</strong></li></ul></li><li><strong>软技能</strong><ul><li><strong>开源文化</strong><ul><li><em>大教堂与集市</em></li></ul></li><li><strong>软件工程</strong><ul><li><em>人月神话</em></li></ul></li><li><strong>非技术</strong></li></ul></li></ul><h4 id="技术社区"><a href="#技术社区" class="headerlink" title="技术社区"></a>技术社区</h4><h4 id="会议论文"><a href="#会议论文" class="headerlink" title="会议论文"></a>会议论文</h4><p>适合跟踪学术界的最新动态。</p><ul><li><strong>OS 领域</strong></li></ul><h4 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h4><p>适合了解行业发展趋势，尤其是从商业角度。</p><h3 id="个人信息源"><a href="#个人信息源" class="headerlink" title="个人信息源"></a>个人信息源</h3><p>个人信息源有时候比公共信息源更珍贵，如果你恰好找到了</p><h4 id="公众号-1"><a href="#公众号-1" class="headerlink" title="公众号"></a>公众号</h4><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><h2 id="原则与方法"><a href="#原则与方法" class="headerlink" title="原则与方法"></a>原则与方法</h2><h3 id="有计划地训练自我"><a href="#有计划地训练自我" class="headerlink" title="有计划地训练自我"></a>有计划地训练自我</h3><blockquote><p><em>你最大的责任就是把你这块材料铸造成器。——易卜生</em></p></blockquote><h3 id="输出式的学习"><a href="#输出式的学习" class="headerlink" title="输出式的学习"></a>输出式的学习</h3><h2 id="认可"><a href="#认可" class="headerlink" title="认可"></a>认可</h2><p>之前讲的都是如何塑造自己成为 “Who I am”，这里要讲的是 “What others think I am”。</p><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><ul><li>职业履历</li><li>项目经历</li></ul><h3 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h3><ul><li>开源贡献（如内核补丁提交经历）</li><li>创作</li></ul><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><h4 id="RHCA"><a href="#RHCA" class="headerlink" title="RHCA"></a>RHCA</h4><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><p>待更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;角色定位&quot;&gt;&lt;a href=&quot;#角色定位&quot; class=&quot;headerlink&quot; title=&quot;角色定位&quot;&gt;&lt;/a&gt;角色定位&lt;/h2&gt;&lt;p&gt;从事任何行业都应当首先找准自己的角色定位，即世界需要什么，以及自身能够贡献何种价值。&lt;/p&gt;
&lt;p&gt;操作系统开发的特点：&lt;/</summary>
      
    
    
    
    <category term="技术人生" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 环境下基于 Hexo 搭建个人博客</title>
    <link href="http://example.com/2020/11/08/using-hexo/"/>
    <id>http://example.com/2020/11/08/using-hexo/</id>
    <published>2020-11-08T15:19:33.000Z</published>
    <updated>2020-12-28T00:10:08.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hexo 是一个快捷、简单、强大的博客生成框架，用户只需使用 Markdown 或其他标记语言写作，Hexo 将负责自动生成美观的静态网页。</p><h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>安装 Git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install git</span></span><br></pre></td></tr></table></figure><p>配置 Git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span></span><br></pre></td></tr></table></figure><p>安装 Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -sL https://deb.nodesource.com/setup_15.x | sudo -E bash -</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -y nodejs</span></span><br></pre></td></tr></table></figure><p>安装 Hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>在根目录下生成 SSH 密钥对：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t -rsa <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后复制 <code>~/.ssh/id_rsa.pub</code> 文件的内容，添加到 GitHub 上。检测公钥设置是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh git@github.com</span></span><br><span class="line">Hi PrinterFranklin! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>在 GitHub 上新建一个仓库，名字是“用户名+github.io”，例如我的用户名是 PrinterFrankin，对应的仓库名就是 PrinterFranklin.github.io。</p><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>使用 hexo 初始化博客：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myblog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myblog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure><p>测试博客：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo s --debug</span></span><br></pre></td></tr></table></figure><p>这个命令会生成博客站点的预览，可以在 <code>localhost:4000</code> 进行访问。如果对文件进行了修改，只需刷新页面就能预览最新的效果。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>在博客根目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="string">&quot;新文章标题&quot;</span></span></span><br></pre></td></tr></table></figure><p>编辑 <code>source/_post/</code> 目录下新增的 .md 文件，并保存。</p><p>如果文章中使用了图片，需要进行如下配置：</p><ol><li><p>安装 hexo-asset-image 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-asset-image --save</span></span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 配置文件中，修改 post_asset_folder 字段为 true。</p><blockquote><p>之后每通过 <code>hexo new</code> 新建文章的时候都会同步在 <code>_post</code> 目录下生成一个同名目录，用于存放文章中引用到的图片。</p></blockquote></li></ol><p>插入图片时，首先将图片存储在文章同名资源目录下，然后在文章中通过 <code>![test](test.jpg)</code> 语法引用。</p><h3 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h3><p>配置 <code>_config.yml</code> 文件，找到 <code>deploy</code> 字段，添加 GitHub 仓库信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:PrinterFranklin/PrinterFranklin.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>还需要安装 Hexo 部署插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure><p>根据以下命令进行部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g<span class="comment"># hexo generate 生成静态站点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo d<span class="comment"># hexo deploy 部署到远端</span></span></span><br></pre></td></tr></table></figure><p>接下来还需要等待一段时间完成网站部署，之后博客就能访问啦。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>升级 Hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm update hexo -g</span></span><br></pre></td></tr></table></figure><h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>Hexo 官网的主题页面提供了很多主题供用户挑选：<a class="link"   href="https://hexo.io/themes/" >https://hexo.io/themes/<i class="fas fa-external-link-alt"></i></a> 。</p><p>更换一个新的主题，你需要：</p><ol><li>在 <code>themes</code> 目录下创建一个新目录，将新主题的文件放在下面。</li><li>编辑 <code>_config.yml</code> 文件，修改 <code>theme</code> 字段的值为新的主题。</li></ol><p>我使用的主题是 ILS：<a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep<i class="fas fa-external-link-alt"></i></a> 。这款主题有效集成了一些实用插件，能够降低部署难度，让你更好地专注于写作本身。</p><p>当然，如果对其他主题都不满意的话，你也可以开发一个自己的主题 ;-)</p><h3 id="添加评论模块"><a href="#添加评论模块" class="headerlink" title="添加评论模块"></a>添加评论模块</h3><p>主要有 Valine 和 GitTalk 两种方法，具体可参考主题提供的相关说明。</p><h3 id="配置个性域名"><a href="#配置个性域名" class="headerlink" title="配置个性域名"></a>配置个性域名</h3><ol><li>找域名提供商购买一个你喜欢的域名，与 Github Pages 默认域名关联起来。</li><li>把域名写到 <code>source/CNAME</code> 文件中。</li></ol><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>快速部署已经能满足最基本的使用需求，但托管在 Github 上的是静态网页文件，并非源文件，源文件只保存在初始化博客的电脑中，这种方案的缺点在于：</p><ol><li>初始化博客的电脑挂了，博客也就挂了，只能重新搭一个。</li><li>没法在另外一台电脑上更新博客（比如发现有错别字的时候）。</li></ol><p>很容易想到把源文件也放到 Github 托管，之后在新电脑上写博客的时候需要：</p><ol><li>用 <code>git pull</code> 更新博客源文件；</li><li>更改源文件，走正常的快速部署流程部署到远端；</li><li>上传更新后的源文件（以确保多端同步）。</li></ol><p>这样做显然很麻烦，那么有没有一种方案，可以只往源文件 <code>git push</code>，就能自动执行 <code>hexo g &amp; hexo d</code> 完成静态网页的生成和博客的部署呢？</p><p>这里使用的是基于 <strong>Github Actions</strong> 的方案，不阐述过多的基础知识，需要了解背景的读者可以参考阮一峰的 <a class="link"   href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" >GitHub Actions 入门教程<i class="fas fa-external-link-alt"></i></a>。</p><blockquote><p>注：常用的 CI/CD 工具都可以满足自动部署需求，你也可以使用更老牌的 Travis CI：<a class="link"   href="https://keep.xpoet.cn/2020/11/%E4%BD%BF%E7%94%A8-Travis-CI-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-Hexo-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/" >使用 Travis CI 自动部署 Hexo 静态博客<i class="fas fa-external-link-alt"></i></a> 。但这种方案有个缺点，那就是源文件必须存放在公共仓库（私有仓库使用 Travis CI 要收费），可能造成一定的安全风险。</p></blockquote><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li><p>在 Github 上新建一个源文件仓 hexo-source，设置成私有仓库。</p><blockquote><p>注：源文件必须存放在私有仓库，以避免 App Key 等敏感信息泄露。</p></blockquote></li><li><p>生成一对密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -f github-deploy-key</span></span><br></pre></td></tr></table></figure><p>把私钥 <code>~/.ssh/github-deploy-key</code> 的内容放到<strong>源文件仓</strong> hexo-source 的 <code>Settings -&gt; Secrets</code> 目录下，命名为 <code>HEXO_DEPLOY_PRI</code>。</p><p>把公钥 <code>~/.ssh/github-deploy-key.pub</code> 的内容放到<strong>静态文件仓</strong> xxx.github.io 的 <code>Settings -&gt; Deploy keys</code> 目录下，命名为 <code>HEXO_DEPLOY_PUB</code>。</p><blockquote><p>注：一定要勾选 <code>Allow write access</code>！否则会因为无法写入会导致部署失败。</p></blockquote></li><li><p>在博客目录下新建 <code>.github/workflows/deploy.yml</code> 文件，内容参考如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">你的git用户名</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">你的git提交邮箱</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">xxx.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">14.</span><span class="string">x</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$HEXO_DEPLOY_PRI&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_USER</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>该文件就是 Github Actions 脚本，你需要修改的只有 <code>GIT_USER</code>、<code>GIT_EMAIL</code> 和 <code>DEPLOY_REPO</code>。</p></li><li><p>上传博客目录到 Github 源码仓：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;init hexo blog&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你使用 <code>git clone</code> 方式下载主题的源码，建议删除主题目录下的 .git 文件。</p></blockquote></li><li><p>等 Actions 脚本跑完后，就能在网站上看到更新的博客啦。</p></li></ol><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>每次更新后需要手动刷新 GitHub 个性域名？</p><p>答：在 <code>source</code> 目录下添加一个新文件 CNAME，内容是自定义域名。</p></li><li><p>哪里能获取到更多关于 Hexo 的信息？</p><p>答：推荐 Easy Hexo 团队提供的<a class="link"   href="https://easyhexo.com/" >轻松入门 Hexo<i class="fas fa-external-link-alt"></i></a>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快速上手&quot;&gt;&lt;a href=&quot;#快速上手&quot; class=&quot;headerlink&quot; title=&quot;快速上手&quot;&gt;&lt;/a&gt;快速上手&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    <category term="新工具" scheme="http://example.com/categories/%E6%96%B0%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="开源" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90/"/>
    
    <category term="博客" scheme="http://example.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>开源指北：为自己的项目建立贡献者协议</title>
    <link href="http://example.com/2020/11/08/add-contributor-license-agreement/"/>
    <id>http://example.com/2020/11/08/add-contributor-license-agreement/</id>
    <published>2020-11-08T07:26:14.000Z</published>
    <updated>2020-12-28T00:10:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>本文已作为 Gitee 社区《开源指北》的一部分对外开源，原文链接位于：<a class="link"   href="https://gitee.com/oschina/gitee-osguide" >https://gitee.com/oschina/gitee-osguide<i class="fas fa-external-link-alt"></i></a> 。</p><h2 id="什么是贡献者协议"><a href="#什么是贡献者协议" class="headerlink" title="什么是贡献者协议"></a>什么是贡献者协议</h2><p>启动自己的开源项目后，除了为项目选择一个合适的开源许可证（License），一份规范的贡献者协议通常也是不可或缺的。事实上，几乎所有大型的开源项目，诸如 Apache、Kubernetes 等，都要求在提交 PR 前签署贡献者协议。</p><p>你可能会问，License 不够用吗？为什么还要加一个贡献者协议呢？这就得从著作权说起了。</p><p>从原理上说，软件开源开放的是软件的<strong>使用权</strong>，而非<strong>著作权</strong>（版权）。开源许可证指明了用户在某些限制下使用软件及其源代码，如果用户违反了开源许可证，最终依然要回归到著作权的法律框架下解决争端。</p><p>那么著作权是怎么来的呢？根据《著作权法》的规定，著作权是作品完成时自然产生的，归作品的作者所有。对于大多数开源项目来说，著作权并不属于单一的人或实体，而是所有贡献者都有一份。可以想象，如果发生开源软件侵权，著作权的分散将给维权带来很多麻烦。另外，假如项目所有者想要更换或调整开源许可证，会因为并不持有全部的著作权受到阻碍，还可能由于著作权的原因与贡献者产生潜在的争议。</p><p>贡献者协议就是为了解决这些问题而生的：</p><ol><li><p>将代码的版权统一授予项目所有者，方便项目的管理和维权。</p></li><li><p>提供保证和免责声明，避免潜在的法律风险。</p><blockquote><p>设想这样一种场景，Alice 为项目贡献了实际为 Bob 所有的代码，并且未获得 Bob 的授权，但 Alice 在提交代码前签署了贡献者协议，保证代码来自于个人原创，此时法律责任完全由 Alice 承担。</p></blockquote></li></ol><p>具体到形式上，贡献者协议又可以分为 CLA 和 DCO，两者在不同场景下各有优劣。</p><h2 id="CLA-vs-DCO"><a href="#CLA-vs-DCO" class="headerlink" title="CLA vs DCO"></a>CLA vs DCO</h2><h3 id="CLA"><a href="#CLA" class="headerlink" title="CLA"></a>CLA</h3><p><strong>CLA</strong>，全称 Contributor License Agreement（贡献者许可协议），简单来说就是项目接收贡献者提交的 PR 之前，需要贡献者签署的一份协议，协议只需签署一次，对该贡献者的所有提交都生效。</p><p>CLA 由项目所有方<strong>自行定义</strong>，在细节上有大大小小的差异，没有统一的标准，但大致包括以下内容：</p><ul><li>关于签署该 CLA 的<strong>主体</strong>和<strong>贡献</strong>的定义；</li><li>授予著作权和专利许可给拥有该软件知识产权的公司或组织；</li><li>签署者保证依法有权授予上述许可；</li><li>所有的贡献内容均为个人<strong>版权所有</strong>，或经过版权所有者的授权，对于贡献内容造成的侵权并不知情；</li><li>贡献内容的<strong>免责声明</strong>；</li><li>说明贡献者提交非原创作品应该采用的方式；</li><li>保证在获悉任何方面不准确的事实或情况之时通知签约方。</li></ul><p>有些项目的 CLA 会相对宽松，例如 Apache 基金会的 CLA 允许贡献者持有著作权，只要求授予项目方分发展示复制等权利。</p><h3 id="DCO"><a href="#DCO" class="headerlink" title="DCO"></a>DCO</h3><p><strong>DCO</strong>，全称 Developer Certificate of Origin（开发者原创证书），最初是在 Linux kernel 项目中引入的，由 Linux 基金会于 2004 年制定。</p><p>相比于 CLA，DCO 是一种更轻量化的机制，它最大的优点是<strong>标准化</strong>，不要求开发者阅读冗长的法律条文，只需在提交的时候签署邮件地址即可。DCO 被很好地集成在了 kernel 的版本控制软件 git 里，因此只要在 <code>git commit</code> 的时候添加 <code>-s</code> 选项，<code>Signed-off-by</code> 就能很简单地添加到 commit log 中。</p><p>DCO 目前最新版本是 1.1，内容如下：</p><blockquote><ol><li>该贡献全部或部分由我创建，我有权根据文件中指明的开源许可提交；或者：</li><li>该贡献是基于以前的工作，这些工作基于适当的开源许可，无论这些工作全部还是部分由我完成，我有权根据相同的开源许可证（除非我被允许根据不同的许可证提交）提交修改后的工作；或者：</li><li>该贡献由1、2、或 3 认证的其他人直接提供给我，而我没有对其进行修改。</li><li>我理解并同意该项目和贡献是公开的，并且该贡献的记录（包括我随之提交的所有个人信息，包括我的签字）将无限期保留，并且可以与本项目或涉及的开源许可保持一致或者重新分配。</li></ol></blockquote><p>协议的核心在于“原创性确认”，也就是让补丁的提交者确认提交内容是自己创作或者经过别人授权的，并且充分了解项目方会如何使用自己的代码。</p><p>正是由于 DCO 保留了 CLA 中的核心免责信息，并且具有轻量化特点，越来越多的开源项目，比如 Chef 和 GitLab 选择从 CLA 切换到了 DCO。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>两种协议的对比如下：</p><table><thead><tr><th>属性</th><th>CLA</th><th>DCO</th></tr></thead><tbody><tr><td>签署方式</td><td>一次性签署</td><td>每次提交时追加 Signed-off-by 信息</td></tr><tr><td>法律责任</td><td>明确法律义务</td><td>无声明，用来限制提交者遵守开源 LICENSE</td></tr><tr><td>自定义</td><td>公司或组织可自行定义</td><td>不可自定义，内容固定</td></tr><tr><td>社区属性</td><td>弱</td><td>强</td></tr><tr><td>公司属性</td><td>强，可签署公司级别的 CLA</td><td>弱</td></tr><tr><td>使用案例</td><td>Google、CNCF、Alibaba、openEuler</td><td>GitLab、Chef、Apache SkyWalking</td></tr></tbody></table><p>说了这么多，究竟应该选择 CLA 还是 DCO 呢？这取决于项目本身和社区的需求，通常来说：</p><ul><li>如果你想尽量减少对开发者贡献代码的阻碍，看重社区内的自由合作，那么 DCO 更合适。</li><li>如果你的开源项目可能有公司间的合作或者要贡献给基金会，注重防范法律风险，那么使用 CLA 更加合适。</li></ul><h2 id="编写自己的-CLA"><a href="#编写自己的-CLA" class="headerlink" title="编写自己的 CLA"></a>编写自己的 CLA</h2><p>下面以 RT-Thread 社区 CLA 为例，介绍如何编写一份规范的 CLA，如果没有特殊的需求，读者也可以直接照搬。</p><p>开头首先明确 CLA 的生效条件和作用范围：</p><blockquote><p>通过签署贡献协议（“本协议”），签署的“贡献者”同意接受“本协议”并受“本协议”约束。“本协议”适用于“贡献者”提交给 xxx 社区 （“社区”）的全部项目（后称“项目”）的“贡献”，无论“贡献”是在签署日期之前，签署时还是之后提供。</p></blockquote><p>接下来对协议中用到的名词进行准确定义：</p><blockquote><p><strong>“贡献”</strong>是指受版权法保护的，由“贡献者”有意“提交”以包含在“项目”所分发软件中任何作品。“提交”是指以电子，口头或书面交流的任何形式送给“社区”管理方或其代表，包括但不限于“社区”管理方为管理的为讨论和改进项目所提供的电子邮件列表上的交流，源代码控制系统以及由“社区”管理方或其代表管理的问题跟踪系统，但不包括由“我”明确标记或以书面形式指定为“非贡献”的交流。</p><p><strong>“贡献者”或“我”</strong>是指下面签名栏中标明的个人或法人实体。对于法人实体，做出“贡献”的实体以及由该实体控制、受其控制或受其共同控制的所有其他实体均被视为“贡献者”。就本定义而言，“控制”是指有受控方或共同受控方至少50%直接或间接的投票权，资金或其他有价证券。</p></blockquote><p>核心部分是贡献者对社区授予版权和专利许可：</p><blockquote><p>“贡献者”授予“社区”管理方和由“项目”所分发的软件的每个接收者一个永久性的、全球性的、免费的、非独占的、不可撤销的、有分许可权的版权许可，供其复制、使用、修改、分发其“贡献”，不论修改与否。</p><p>“贡献者”授予“社区”管理方和由“项目”所分发的软件的每个接收者一个永久性的、全球性的、免费的、非独占的、不可撤销的、有分许可权的专利许可，供其制造、委托制造、使用、许诺销售、销售、进口其“贡献”或以其他方式转移其“贡献”。前述专利许可仅限于“贡献者”现在或将来拥有或控制的其“贡献”本身或其“贡献”与“提交”“贡献”时所针对的“项目”软件的结合而将必然会侵犯的专利权利要求，不包括仅因“贡献者”之外的人修改“贡献”或其他结合而将必然会侵犯到的专利权利要求。如由“项目”所分发的软件实际采用的许可证对软件接收者的专利授权有进一步限制规定的，如限制接收者对“贡献”或前述软件发起专利诉讼或其他维权等，则对前述软件接收者的专利授权以具体项目许可证的对应规定为准。</p></blockquote><p>最后是贡献者的保证和免责声明：</p><blockquote><p>“贡献者”保证“我”是“贡献”的版权所有者，或者“我”经版权所有者授权进行“贡献”，并且“我”在法律上授予“本协议”规定的权利。</p><p>“贡献者”保证“我”不知晓“我”的任何“贡献”已经侵犯或将侵犯任何第三方的版权，商标，专利或其他知识产权。</p><p>除“本协议”明确约定外，“贡献者”的  “贡献”在提供时不带任何明示或默示的担保，“贡献者”或版权所有者不对任何人因使用“项目”所分发的软件或其中的“贡献”而引发的任何直接或间接损失承担责任，不论因何种原因导致或者基于何种法律理论，即使其曾被建议有此种损失的可能性。</p></blockquote><p>到此为止，一份完整的 CLA 就大功告成啦，通常协议下方还会有表单用于收集贡献者的姓名和邮箱，以便在提交 PR 时检查贡献者是否签署了 CLA。</p><p>很多 FOSS 项目（Free and Open-Source Software）在开始时并没有要求贡献者签署  CLA，但伴随着项目参与者越来越多，会有签署 CLA 以及更改 License 的需求，此时可能面临一些困难，例如无法找到过去的贡献者重新签署  CLA。为了避免被起诉的风险，通常会采用两种策略：</p><ol><li>重写受影响的部分代码，适用于受影响代码较少的情形。</li><li>保持现有的状态直到所有贡献者签署 CLA，适用于受影响代码较多的情形。</li></ol><p>所以如果你已经决定要开源自己的代码，并且想要把它做成一个参与者众的大型项目，建议提前考虑好是否要添加贡献者协议，因为越晚考虑的成本可能会越高。</p><h2 id="题外话：CLA-面面观"><a href="#题外话：CLA-面面观" class="headerlink" title="题外话：CLA 面面观"></a>题外话：CLA 面面观</h2><p>虽然 CLA 在开源软件中得到了广泛运用，但关于它的争议一直没有停歇过。</p><p>反对者认为 CLA 与开源运动的初衷相违背，多数情况下签署 CLA 即意味着<strong>放弃自己劳动成果的版权</strong>（或者说著作权），一旦版权转移给了项目方，项目方就有权在未来更换其他更严格的许可证，甚至直接将项目闭源，这显然是贡献者不愿意看到的。</p><p>除此以外，CLA 的<strong>非标准性</strong>可能导致贡献者和项目方处于地位不对等的状态，贡献者需要在参与每个项目时都仔细检查一遍条款，以避免自己的劳动成果被恶意利用，事实上在繁琐的协议条文面前，拥有成熟法务团队的大公司总是处于主导地位，这与尽可能降低门槛、崇尚自由合作的开源精神不符。</p><p>当然也不乏支持 CLA 的声音，理由之一是，CLA 的存在是一种应对法务风险的防御机制，很多大型企业基于开源软件构建产品并对客户提供服务，如果有开源社区的贡献者起诉他们侵犯专利或版权，败诉不仅意味着巨额的赔偿，还可能导致业务中断损失客户。</p><p>CLA 让更多大型企业和组织愿意参与开源社区并成为其中的中坚力量，企业在构建产品的过程中反哺开源社区，提高开源软件的代码质量，可以说没有大型企业和组织，也就没有丰富和高质量的开源软件生态，从这点上来说，CLA 也是一种“存在即合理”。</p><p>对此，你怎么看呢？</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://en.wikipedia.org/wiki/Contributor_License_Agreement" >https://en.wikipedia.org/wiki/Contributor_License_Agreement<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://jimmysong.io/blog/open-source-cla/" >https://jimmysong.io/blog/open-source-cla/<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/kubernetes/community/issues/2649" >https://github.com/kubernetes/community/issues/2649<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://opensource.com/article/18/3/cla-vs-dco-whats-difference" >https://opensource.com/article/18/3/cla-vs-dco-whats-difference<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="http://opensource.guide/zh-hans/" >http://opensource.guide/zh-hans/<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.finnegan.com/en/insights/articles/what-you-should-know-about-contributor-license-agreements-in-open-source-projects.html" >https://www.finnegan.com/en/insights/articles/what-you-should-know-about-contributor-license-agreements-in-open-source-projects.html<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://opensource.stackexchange.com/questions/666/what-can-you-do-if-you-cant-track-down-all-old-contributors-to-sign-a-cla?rq=1" >https://opensource.stackexchange.com/questions/666/what-can-you-do-if-you-cant-track-down-all-old-contributors-to-sign-a-cla?rq=1<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://opensource.com/article/19/2/cla-problems" >https://opensource.com/article/19/2/cla-problems<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.rt-thread.org/cla/" >https://www.rt-thread.org/cla/<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="http://disksing.com/cla-and-dco/" >http://disksing.com/cla-and-dco/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文已作为 Gitee 社区《开源指北》的一部分对外开源，原文链接位于：&lt;a class=&quot;link&quot;   href=&quot;https://gitee.com/oschina/gitee-osguide&quot; &gt;https://gitee.com/oschina/gitee-osg</summary>
      
    
    
    
    <category term="开源文化" scheme="http://example.com/categories/%E5%BC%80%E6%BA%90%E6%96%87%E5%8C%96/"/>
    
    
    <category term="开源" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
</feed>
